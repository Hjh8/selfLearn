面试题
===

Java SE
===





## 为什么重写equals还要重写hashcode？

object的equals默认是比较内存地址（跟双等号一样），而hashcode默认是内存地址的哈希值，如果equals重写了，他为true时两个对象的内存地址并不一定相同，这个时候，如果不重写hashcode，那么他会默认用object的hashcode方法，所以他们的hashcode值是不一样的。就导致两个对象equals相等但是hashcode不相等，这个对象应用在hashmap作为key时他们是先判断hashcode是否相等再比较equals，不相等就为不同的key，所以这样的对象不能应用在hashmap和set里作为key。



Error和Exception的区别
---

Error指的是程序无法解决的错误，比如内存不足OutOfMemoryError

Exception通常指的是代码逻辑的异常，比如下标越界OutOfIndexException





CopyOnWriteArrayList添加新元素是否需要扩容？
---

CopyOnWriteArrayList 底层并非动态扩容数组，不能动态扩容，其线程安全是通过 ReentrantLock 来保证的。

当向 CopyOnWriteArrayList 添加元素时，线程获取锁的执行权后，`add` 方法中会新建一个容量为（旧数组容量+1）的数组，然后将旧数组数据拷贝到该数组中，并将新加入的数据放入新数组尾部，接着使用新数组替换旧数组。

代码如下：

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

CopyOnWriteArrayList 适用于，读多写少的情况下（读写分离）！因为每次调用修改数组结构的方法都需要重新新建数组，性能低！





Java Web
===

请你说说，cookie 和 session 的区别？
---

1. 存放位置不同。cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. 数据大小不同。单个cookie保存的数据不能超过4K，而session没有限制。
3. 数据类型不同。cookie中只能保管ASCII字符串。而session中能够存储任何类型的数据。
4. cookie对客户端是可见的，用户可以通过设置cookie来进行伪装，但session不行。
5. 服务器资源。cookie保管在客户端，不占用服务器资源。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户很多，会产生很多的session，耗费大量的内存。





计算机网络篇
===

网络模型
---

![image-20210701091201235](面试题.assets/image-20210701091201235.png)



TCP和UDP的区别
---

1. TCP是面向连接的，提供可靠的服务，而UDP是无连接的，不保证可靠交付。
2. TCP面向字节流，即数据看成一连串无结构的字节流；UDP是面向报文的
3. TCP有确认应答、超时重传、拥塞控制等机制来保证传输可靠，而udp没有。



TCP如何保证可靠
---

- 确认应答与序列号
  - 每次接收方收到数据后，都会对传输方进行确认应答，在应答报文中会带着序列号。
- 超时重传
  - 每一方发出一个报文后，会启动一个**重传计时器**，等待接收方确认收到这个报文。如果在规定时间内没有收到应答，将重发这个报文。
- 三次握手和四次挥手
- 流量控制
  - 通过改变**滑动窗口**的大小来改变发送的数据量，因为双方都有个缓冲空间，超过这个空间的报文将会丢失，所以要实时控制滑动窗口的大小。
  - 当滑动窗口变为0时，会启动**持续计时器**，防止改变滑动窗口的报文丢失。如果持续计时器超时，则会发送窗口探测报文，获取窗口大小。
- 拥塞控制
  - 通过慢启动算法跟拥塞避免算法来进行拥塞控制。一开始使用慢启动算法以指数级增长($2^n$)的方式发送报文，当达到阈值的时候使用拥塞避免算法，只要网络不拥堵，则试探性的增大传输的大小。



一个 TCP 连接可以对应几个 HTTP 请求
---

1. 如果tcp连接保持长连接 Connection:keep-alive；则只要在tcp连接（默认两小时）不断开，可以一直串行发送数量无上限；
2. 如果tcp连接不保持长连接，Connection:close 只能发一次请求；



一个 TCP 连接中 HTTP 请求可以一起发送么（比如一起发三个请求，再三个响应一起接收）
---

在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。

在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行



HTTP2多路复用
---

多路复用就是并行流的方式发送数据。

`HTTP/2`引入`二进制数据帧`，数据帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并。同样是因为有了序列，服务器就可以并行的传输数据。



为什么有的时候刷新页面不需要重新建立 SSL 连接？
---

因为TCP 连接有时候是维持一段时间的，即不需要重新建立连接，SSL 自然也会用之前的。



 简单描述一下，TCP的连接和释放过程
---

### 三次握手的过程

1. 主机A向主机B发送TCP连接请求报文（其中报文中同步标志位SYN=1，序号seq=x），主机A进入同步等待状态。
2. 主机B收到请求后，回复连接确认报文。（其中确认报文中，SYN=1，ACK=1，并含主机B的初始序列号seq(B)=y，以及确认号ack(B)=x+1），主机B进入同步已接收状态。
3. 主机A收到主机B的确认报文后，还需最后发送一个报文，即发送一个ACK=1，序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；完成连接

![img](面试题.assets/20190605141141146.png)



### 为什么需要三次握手？

TCP的三次握手最主要是 防止已过期的报文再次传到服务器后而导致连接错误。



### 四次挥手过程

假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下：

1. 首先客户端发送一个请求断开报文，用来**关闭**客户到服务器的**数据传送**，然后等待服务器的确认。其中 终止标志位FIN=1，序列号seq=u。
2. 服务器收到数据包之后发回一个确认报文，ACK=1，确认号ack=u+1。此时服务器还可以向客服端发送数据。
3. 当服务器发送完数据之后，会再次发送一个请求断开报文给客户端，表示**关闭**服务器到客户端的**连接**（FIN=1，ACK=1，seq=v，ack=u+1）
4. 客户端收到报文后，发回一个确认报文（ACK=1，seq=u+1，ack=v+1）。此时客户端接着进入等待状态并启用**等待计时器**，等待2MSL后进入关闭状态。

![img](面试题.assets/20190605141312931.png)



### 为什么要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？

为了保证服务器能收到客户端的确认应答。若A发完确认应答后直接进入CLOSED状态，那么如果该应答报文丢失，服务器等待超时后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，此时B永远无法正常关闭。



### 为什么要等待2MSL

MSL表示数据包的最大存活时间。

若A发送的确认报文在一个MSL内还没有发到B，则B会重新发送一个数据包。这样一来一回的最大时间就是2MSL。

并且等待2MSL之后，可以确保所有的数据包都已经失效，不会对重新连接的新报文跟老报文发生冲突。



对称加密与非对称加密
---

==对称密钥==加密是指加密和解密使用同一个密钥，这种方式存在的最大问题就是密钥如何安全地将密钥发给对方；

- DES、AES

==非对称加密==是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的**公钥进行加密**，对方接收到加密信息后，使用自己的**私钥进行解密**。

- RSA



Http工作原理
---

HTTP协议（HyperText Transfer Protocol，超文本传输协议）在进行网络通信时双方要遵循的规则。

> 超文本：不仅仅是文本，还可以是图片、视频等



### HTTP请求响应模型

HTTP的请求和响应模型：**客户端/服务器模型（B/S）** 

> C/S：客户端/服务器模型，类似于APP，客户端既要做逻辑处理也要做页面展示。发生一次升级，所有客户端的程序都需要升级。
>
> B/S：浏览器/服务器模型，页面渲染展示交给浏览器，逻辑处理交给服务器。

HTTP是一个无状态的协议。无状态是指 当浏览器向服务器发送请求，服务器返回响应之后，连接就被关闭了，服务器不保留与连接有关的信息。

但可以通过设置`Connection: keep-alive` 来保持一段时间的连接。从HTTP/1.1起，**默认都开启了Keep-Alive**，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。



### HTTP工作过程

地址栏输入域名网址后回车：

1. 地址解析：

   1.1 查看浏览器缓存有无该域名的IP

   1.2 查看本台计算机的DNS缓存，看有没有对应该域名的IP地址（位于`C:\Windows\System32\drivers\etc\hosts`）

   1.3 本地域名服务器查询得到IP地址

2. 将请求解析成HTTP标准的报文格式

3. 三次握手，建立TCP连接，发送请求

4. 得到数据，在浏览器中渲染

5. 四次挥手，关闭TCP连接



### Http请求报文格式

Http请求报文格式固定如下：

![image-20210718222841314](面试题.assets/image-20210718222841314.png)

例如：（ **post请求时必须指定 Content-length** ）

```text
POST /abc/a.html HTTP/1.1
content-type: application/json; charset=utf-8
Content-length:5

username=admin&age=3
```



### Http响应报文格式

Http响应报文格式固定如下：

![image-20210718224219281](面试题.assets/image-20210718224219281.png)

例如：

```text
HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <p>哈哈哈哈</p>
</body>
</html>
```



### Http请求方法

| 方法    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 请求页面信息，获得数据。                                     |
| HEAD    | 类似于get请求，只不过获取的是HTTP的头信息。通常用于检查超链接的有效性 |
| POST    | 向服务器资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。 |
| PUT     | 更新服务器资源                                               |
| DELETE  | 删除服务器资源                                               |
| OPTIONS | 获取服务器可以请求的方法                                     |



### GET和POST的区别

1. **传递方式**：GET参数通过URL传递，POST放在Request body中。因为很多浏览器的URL长度是有限制的，所以get参数的大小也有限制。
2. **请求编码**：GET请求只能进行url编码，而POST支持多种编码方式。
3. **浏览器回退**：GET在浏览器回退时单纯回到页面，而POST会再次提交请求。
4. **浏览器缓存**：GET请求会放入浏览器cache中，而POST不会，除非手动设置。



http与https的区别
---

http运行在tcp之上，使用明文进行传输，是无状态的（客户端和服务端都无法验证对方的身份），端口号是80；

https是http的基础上加了SSL(Secure Socket Layer)，在传输的过程中会进行加密和认证，端口号是443。资源消耗比http大。



https工作原理
---

> SSL四次握手+加密的http通信方式

1. 客户端发出请求

   客户端先向服务器发出加密通信的请求，并生成一个随机数，这被叫做ClientHello请求。

2. 服务器回应

   服务器收到客户端请求后，确定加密算法以及生成一个随机数，向客户端发出回应，把证书发给客户端，这叫做SeverHello。

3. 客户端回应

   客户端收到服务器回应以后，首先会验证服务器证书，如果证书可靠，则生成第三个随机数，接着取出证书里面的公钥对新生成随机数（pre-master key）进行加密，然后发给服务器。

4. 服务器的最后回应

   服务器收到客户端的加密后的随机数之后，通过私钥进行解密，此时客户端和服务器都拥有了三个随机数，然后两者根据约定好的加密算法生成本次会话所用的"会话密钥"。然后，服务器向客户端发送下面信息。

   编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

   服务器握手结束通知，表示服务器的握手阶段已经结束。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。



SSL握手的目的
---

保证客户端与服务器之间密钥的交换是安全的。握手期间使用的加密算法是非对称加密，通信期间使用的是对称加密。





操作系统
===

进程和线程的区别是什么
---

1. 进程是资源分配的最小单位，线程是资源调度的最小单位
2. 一个进程至少有一个线程，多个线程可共享进程所拥有的资源，线程必须存活在进程中。
3. 程序之间的切换会有较大的开销；线程之间切换的开销小。 每个线程都有自己独立的栈空间和程序计数器。



什么情况下会发生死锁？
---

**互斥**：一个资源一次只能被一个进程访问。

**请求与保持**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

**不可剥夺**：进程已经获得的资源，在未使用完之前不能强行剥夺。

**循环等待**：若干资源形成一种头尾相接的循环等待资源关系。





场景题
===

从大数据量的找出出现次数最多的，或者前多少大/小的
---

**问题**：

1. 假设有1kw个身份证号，以及他们对应的数据。身份证号可能重复，要求找出出现次数最多的前100个身份证号。
2. 怎么在海量数据中找出重复次数最多的一个
3. 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。

**解题思路**：都是采用分支然后归并的方法。

1. 对数据取hash值然后除以一个数n取模，然后将数据分到n个小文件中
2. 对于每个小文件，可以把 数据 作为key，出现次数作为value 存入 hashMap中。
3. 分别对这些小文件进行处理，如排序，取出次数最多的
4. 合并所有的小文件，得出结果

***

比如第一题

1. hash(身份证号)%1000，将身份证号存储到1000个小文件中，每个小文件就只有1w条的数据
2. 对于每个小文件，把身份证作为key，出现次数作为value存入hashMap中。
3. 然后读取每个文件hashMap的次数最多的前100个身份证号使用归并排序存入到一个文件中。
4. 然后读取每个文件出现次数最多的前100个身份证。



JWT生成token有几个部分
---

JWT是 JSON Web Token的缩写，是一种安全的规范，使用JWT可以让我们在用户端和服务端建立一种可靠的通信保障。

JWT有三个部分组成：

1. header：描述JWT的元数据，定义了生成签名的算法以及token的类型
   - 这里指定为RSA256非对称加密算法，类型默认是jwt
2. payload：负载，用来存放要传递的数据，比如用户的基本信息和token过期时间
3. signature：签名，使用 密钥和指定的算法 对header和payload进行签名。

流程：

1. 用户登录时后端返回一个token，前端将其保存在sessionstroage中
2. 前端每次请求中携带token字段，该字段中携带token信息
3. 后端拦截器拦截请求后验证token字段
   - 公钥对签名解密，解密出来的header和payload的信息是否和传过来的一致。





