面试题
===

Java SE
---

为什么重写equals还要重写hashcode？
---

object的equals默认是比较内存地址（跟双等号一样），而hashcode默认是内存地址的哈希值，如果equals重写了，他为true时两个对象并不一定内存地址一样，这个时候，如果不重写hashcode，那么他会默认用object的hashcode方法，所以他们的hashcode值是不一样的。就导致两个对象equals相等但是hashcode不相等，这个对象应用在hashmap作为key时他们是先判断hashcode是否相等再比较equals，不相等就为不同的key，所以这样的对象不能应用在hashmap和set里作为key







计算机网络篇
===

网络模型
---

![image-20210701091201235](面试题.assets/image-20210701091201235.png)



TCP和UDP的区别
---





TCP如何保证可靠
---





 简单描述一下，TCP的连接和释放过程
---

### 三次握手的过程

1. 主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。（其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）；
2. 主机B收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及确认号ack(B)=x+1）
3. 主机A收到主机B的确认报文后，还需最后发送一个确认包，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；完成连接

![img](面试题.assets/20190605141141146.png)



### 为什么需要三次握手？

TCP的三次握手最主要是 防止已过期的连接包再次传到服务器。



### 四次挥手过程

假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下：

1. 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。
2. 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。
3. 关闭服务器到客户端的连接：也是发送一个FIN给客户端。
4. 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

![img](面试题.assets/20190605141312931.png)



### 为什么要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？

为了保证服务器能收到客户端的确认应答。 

若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。



### 为什么要等待2MSL

MSL表示数据包的最大存活时间。

若A发送的确认报文在一个MSL内还没有发到B，则B会重新发送一个数据包。如果B重新发送的数据包在一个MSL内也没有到达A，则A还处于TIME-WAIT状态，此时A会重新发送确认数据包。





对称加密与非对称加密
---

==对称密钥==加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；

- DES、AES

==非对称加密==是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的**公钥进行加密**，对方接收到加密信息后，使用自己的**私钥进行解密**。

- RSA



介绍一下http
---





http与https的区别
---

http运行在tcp之上，使用明文进行传输，是无状态的（客户端和服务端都无法验证对象的身份），端口号是80；

https是http的基础上加了SSL(Secure Socket Layer)，在传输的过程中会进行加密和认证，端口号是443。资源消耗比http大。



https工作原理
---

> SSL四次握手+加密的http通信方式

1. 客户端发出请求

   客户端先向服务器发出加密通信的请求，并生成一个随机数，这被叫做ClientHello请求。

2. 服务器回应

   服务器收到客户端请求后，确定加密算法以及生成随机数，向客户端发出回应，把证书发给客户端，这叫做SeverHello。

3. 客户端回应

   客户端收到服务器回应以后，首先会验证服务器证书，如果证书可靠，则生成第三个随机数，接着取出证书里面的公钥对新生成随机数（pre-master key）进行加密，然后发给服务器。

4. 服务器的最后回应

   服务器收到客户端的加密后的随机数之后，客户端和服务器都拥有了三个随机数，此时两者会根据约定好的加密算法生成本次会话所用的"会话密钥"。然后，服务器向客户端发送下面信息。

   编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

   服务器握手结束通知，表示服务器的握手阶段已经结束。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。



SSL握手的目的
---

保证客户端与服务器之间密钥的交换是安全的。握手期间使用的加密算法是非对称加密，通信期间使用的是对称加密。









