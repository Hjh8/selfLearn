NIO 学习
===



I/O 模型基本说明
---

I/O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能。

> IO操作要把数据从 **内核**缓冲区 拷贝到 **用户**缓冲区

`阻塞IO模型`：当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪则等待数据就绪，此时用户线程就会处于阻塞状态，**用户线程交出CPU**。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才重新运行。

`非阻塞IO模型`：当用户线程发出IO请求后，并不需要等待，而是马上就得到了一个结果。若此时内核的数据还没有就绪，则返回一个错误，用户线程得到错误结果后会一直**重复查看内核的数据是否准备就绪**。

> 非阻塞IO不会频繁的切换线程（切换线程开销大），而是一直占用CPU。但非阻塞IO就有一个非常严重的问题，需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高。

`IO复用`：当用户线程发出IO请求后，不需要等待，直接继续往下执行，**CPU会开启一个线程来检查内核的数据**，一旦内核的数据准备就绪，能够通知用户线程进行操作。为什么叫复用？因为这个线程可以检查多个IO请求的内核数据，哪个请求的数据先准备好就先通知哪个请求。

`异步IO模型`：当用户线程发出IO请求后，会**告诉内核拿到数据后要怎么处理，处理完成之后再通知用户线程**，并把结果返回给用户线程。



BIO、NIO、AIO
---

Java 共支持 3 种网络编程的/IO 模型：**BIO、NIO、AIO**。

Java BIO：同步阻塞模型，服务器实现模式为一个线程处理一个请求，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果一个连接不做任何事情则对应的线程会一直等待。

Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)。客户端发送的连接请求都会注册到 多路复用器 上，多路复用器 轮询到有 I/O 请求就通知服务器进行处理。

Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器启动线程进行处理。





NIO介绍
---

Java NIO（New IO）也有人称之为non-blocking IO，从Java 1.4版本开始引入的一个新的IO API。NIO面向**缓冲区**的、基于**通道**的IO操作。NIO将以更加高效的方式进行文件的读写操作。



### NIO与BIO的区别

| NIO                       | BIO                 |
| ------------------------- | ------------------- |
| 面向缓冲区（Buffer）      | 面向流（Stream）    |
| 非阻塞（Non Blocking IO） | 阻塞IO(Blocking IO) |
| 选择器（Selectors）       |                     |









