# 第一天

## 工作内容

1. 学习及了解QFC制度
2. 学习git的线上课程，如了解git的简介，git常用命令的使用
3. 根据线上课程进行实践，将实践后的新的写进wiki





## 心得体会

1. 对版本管理有了更进一步的了解与认知

2. 对git的一些操作更加的了解，进行了查缺补漏，比如对git diff指令的理解：`git diff`：显示**工作区域跟暂存区域**之间所有文件的差别。
   - `git diff --cached`：显示**暂存区域跟本地仓库**之间所有文件的差别。
   - `git diff 版本1 版本2`：显示**工作区域跟暂存区域**之间版本1对于版本2的差异。
   - `git diff 分支1 分支2`：显示**工作区域跟暂存区域**之间分支1对于分支2的差异。



## 问题



CR系统一直差不多我的作业提交记录



## 明日计划

完善Git学习笔记，以及完成明天的作业







# 第二天

## 工作内容

1. 根据询问周围同事、导师以及查阅文档的形式解决了昨日提交作业后CR系统查不到我的提交记录的问题。
2. 学习《从校园到职场》和《如何成为一个合格的程序员》线下课程。
3. 继续学习git线上课程，并完善笔记，完善wiki。



## 心得体会

1. 感受到了公司系统的完善及强大，文档完善的很好，对于新手有很大的帮助，这也启示了我们，平时要养成写文档记录的习惯，方便日后的查看。

2. 线下课程的老师们的课程逻辑性很强，很全面，值得学习。尤其是淡新举老师的程序员从合格到大神的建议和指导，程序员应该从基础的东西开始，慢慢的选择一个方向进行钻研，而不是毫无目的的成为码农。

3. 学习了git的分支及版本管理命令的使用。如git reset命令

   - git reset命令是将本地仓库中HEAD重置到指定状态或将本地仓库的内容覆盖缓存区或工作区的内容。

     - `git reset HEAD~` 或 `git reset --mixed HEAD~`：在本地仓库中将当前提交指向上一次提交，并将上一次提交的内容拷贝到缓存区（工作区不会改变）。
     - `git reset --hard HEAD~`： 在本地仓库中将当前提交指向上一次提交，并将上一次提交的内容拷贝到缓存区和工作区。
     - `git reset --hard 版本号`： 在本地仓库中将当前提交指向指定版本的提交，并将指定版本的提交的内容拷贝到缓存区和工作区。
     - `git reset --soft HEAD~`：在本地仓库中将当前提交指向上一次提交。（工作区和缓存区都不会改变）

     **tips**：使用了reset命令之后，指定回退版本之后的提交的版本都会被清除，除了加上soft参数。



## 问题

问题1：提交作业后CR系统查不到我的提交记录。

原因：首先是因为我没有使用ssh的方式克隆仓库，其次是我的项目大小大于10M。

解决方法：对项目进行瘦身，以及解决git clone错误（下述问题）。

问题2：git clone发生错误。

原因：因为公司发的电脑中存在多个用户，所以需要在单独的用户的.ssh文件夹下添加一个ssh-key 代理的配置文件。

解决方法：在C盘用户目录下的.ssh文件夹下添加一个config文件。[解决办法参考](https://yijiebuyi.com/blog/f18d38eb7cfee860c117d629fdb16faf.html)。



## 明日计划

1. 完成明日的考试，然后对考试的内容进行查缺补漏。
2. 继续完成git的wiki以及笔记，如对一些结构的解释以及画图。



---

wiki地址：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=586922686





# 第三天

## 工作内容

1. 早上10点到11点小组开会，使组内成员相互更加了解，此外还谈论了文化节中脱口秀活动的内容。
2. 11点到下午2点30分，完成考试第一题。
3. 2点30分到5点整，完成考试第二题。
4. 完善git学习笔记以及[wiki](https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=586922686)。



## 心得体会

1. 组内成员都很积极，一起营造了一个上进活跃的环境，尤其是组长的组织能力值得我学习，在敲代码之余还需要学会组织与交谈能力，便于日后与产品、测试的小伙伴进行交流。
2. 明白了做笔记以及wiki的意义，当对之前学过的东西再次需要使用时，如果有些遗忘或者模糊，通过笔记就可以很快速的查找到对应的地方，便于自己快速的记忆起来，大大提高了效率。与此同时，当需要对一些知识点进行复习的时候，可以通过看笔记的形式进行复习，在复习过程中如果有不同的看法或者更好的解释可以立马进行修改，达到温故而知新的效果。



## 问题

**问题1**：对关于日期的操作方法不是很了解。

原因：之前对日期相关的方法及操作接触较少。 

解决方法：通过询问通讯以及百度的方式，来增加自己对日期操作的一些方法的理解。

**问题2**：生产者-消费者模型中，消费者获取不到生产者的数据。 

原因：消费者中没有类似于while循环重复获取数据的操作，只在线程刚创建的时候就执行一次。

解决方法：在消费者类的run方法中加一个while(true)循环。

**问题3：**一开始在生产者-消费者模型中，是使用的是管程法，但解决变成了单线程的情况。

原因：在模型中间的容器类的方法中加了lock锁，但由于需要消费者消费时需要sleep，所以会出现lock在睡眠时不释放锁，导致最后变成单线程的情况。

解决方法：去掉中间容器类，使用阻塞队列代替中间容器类，由于阻塞队列会自动的阻塞和唤醒，所以无需自己上锁与解锁。



## 明日计划

1. 上午学习边实践guava的线上课程（第一节课）。
2. 下午3点至4点，总结上午课程内容。
3. 下午4点到5点，学习边实践guava的线上课程（第二节课）。
4. 下午5点到6点，总结第二节课的课程内容。
5. 剩余时间完善git学习笔记以及wiki。





# 第四天

## 工作内容

1. 学习java&guava线上课程，并以笔记wiki的方式进行总结，Wiki链接：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=588130371
2. 简单阅读StringBuilder的源码，链接如下：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=588131509
3. 小组开会，商讨文化节脱口秀节目



## 心得体会

1. guava的相关方法确实给我们coding带来了便利，可以用简洁的代码实现一些复杂的功能。但就是相关的API有点多，需要日后的实践中慢慢熟悉。
2. 了解了String、StringBuilder以及StringBuffer之间的差别。
   - **String**是final修饰的，每次操作都会产生新String对象。**如果需要不产生新对象则需要使用反射技术进行修改**。
   - StringBuffer跟StringBuilder都是在原对象上进行操作StringBuffer使用synchronized修饰，是线程安全的；StringBuilder是非线程安全的。
3. joda-time对于时间相关操作不仅保证了线程安全，还简便了程序员对于日期相关的操作，比如日期的相加减。具体joda-time相关操作可见如下链接：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=588131495



## 问题

如何加深对管程以及多线程之间的通信的运用及理解？



## 明日计划

1. 利用[可视化网站](https://learngitbranching.js.org/?locale=zh_CN)进行实践，加深我对git操作的理解。
2. 根据老师的建议对之前的作业进行优化





# 7.18

## 工作内容

1. 学习java&guava线下课，并对老师课上遗留的问题通过实际coding进行验证。
2. 学习Future及其扩展，例如CompletableFuture和Listenablefuture。
3. 理解同步/异步、阻塞与非阻塞的定义。



## 心得体会

1. 异常的处理以及注意事项原来那么多，比如在Runnable中异常被吞掉而我们感知不到，进而导致我们难以排查问题。或者需要根据不同的异常做不同的处理，连抛出异常、捕获异常或者利用返回值表示异常都要经过慎重的考虑。
2. 感受到了CompletableFuture函数式编程的简便，不仅美观还简化了我们程序员对于异步编程的复杂性。
3. 当一个可变对象作为HashMap的key时，当第一次放入此对象，然后修改对象其中的一个属性，再次放入时会重新放入此对象。



## 问题

不了解同步/异步、阻塞与非阻塞两两组合之后的意思。

通过查阅博客，咨询同学及导师的方式理解了它们的意思，并整理成笔记，便于以后的复习。

若以可变对象为key放入map，那修改了其中一个属性之后再放入会是什么情况？

会放入两个元素，但key是一样的



## 明日计划

1. 继续学习CompletableFuture的用法。
2. 学习java&guava的线上课程。
3. 整理笔记。
4. 完成java&guava的作业。





# 7.19

## 工作内容

1. 学习java&guava线上课2的内容，如guava的集合工具类，cache类，IO操作，并整理到wiki中：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=588130371
2. 学习CompletableFuture的用法，并整理到wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=588140845



## 心得体会

1. 感觉最近需要学习的知识点比较多，有一部分是没学过的有一部分是学过但有点遗忘的，需要比较长的时间来消化。
2. 由于CompletableFuture之前没有接触过，所以今天刚学习完感觉对异步操作有了一定的感觉，不会像之前一样碰到多线程或者异步的代码时有点不知所措。



## 问题

1. 学习的很多知识点如果没有经常实践运用的话，感觉以后又会遗忘，是不是一些知识点是要用的时候才去进一步了解？
2. CompletableFuture的get方法会进行阻塞，如果自己实现对CompletableFuture的异步操作超时的处理？





## 明日计划

1. 学习java&guava线下课，记录不了解的知识点并查缺补漏
2. 完成java&guava的作业
3. 消化前两天所学的知识点



# 7.20

## 工作内容

1. 学习java&guava线下课
2. 完善7.18日布置的作业。
3. 查阅ReentrantLock加锁解锁的源码，并记录成笔记：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=589868021



## 心得体会

1. 在今日的线下课中，学到了许多日常没有注意到的点，例如：
   - 单例模式更多形式的写法，例如跟缓存搭配在一起，当一定时间或一定次数之后需要重新生成单例。
   - 日志该如何打印，应该打印异常关键字，参数，以及异常栈，并且不要轻易吞掉。
   - 缓存的注意事项，例如缓存穿透，缓存并发等解决方案
2. 对CompletableFuture的使用更加的熟悉，更加了解了其中一些方法的使用以及含义，



## 问题

1. 如何实现过期+次数一起决定单例资源的重新加载？
2. ReentrantLock中为什么先调用LockSupport.park(this); 再调用Thread.currentThread().interrupt();？具体意义是什么？



## 明日计划

1. 学习线下课内容，老师讲解题目遇到不懂的需要记录下来并解决。
2. 完善ReentrantLock阅读，并进行分享。





# 7.21 

## 工作内容

1. 学习线下课内容，听老师讲解之前的作业题，大致思路以及注意事项
2. 接着进行ReentrantLock源码阅读，并更新wiki：[Lock的加锁释放锁过程](https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=589868021) 
3. 听组内成员分享Spring源码
4. 脱口秀会议，商讨脱口秀具体事宜
5. 尝试做java&guava考试



## 心得体会

1. 需要注意String的空值（NULL或“”）以及一个或多个空格组成的空值。判断的时候需要多注意，有时候需要trim之后再判断长度。
2. 认识到组内大佬的强大，以及跟大佬之间的差距。对于Spring的AOP机制更加熟悉，每个含有切面的类在初始化之后都会被Spring重新生成类增强后的byte数组，然后加载成代理类以完成切面功能。
3. 对于一个问题与其自己百度苦苦钻研，不妨请教一下大佬，问题解决的可能更快更明了。今天请教了一下组内成员，为什么ReentrantLock的加锁进入等待队列时需要LockSupport.park(this);之后再Thread.currentThread().interrupt();，原因是如果park之后如果被其他线程中断，则会调用interrupt()自己中断。而如果不想让线程自己中断，想自己来处理，这时ReentrantLock提供了lockInterruptibly()方法。
4. 考试内容越来越难，要理解以及融汇贯通的东西越来越多了。



## 问题

1. isEmpty()与isBlank()的区别？
2. 为什么ReentrantLock的加锁进入等待队列时需要LockSupport.park(this);之后再Thread.currentThread().interrupt();？



## 明日计划

1. 实现过期+次数一起决定单例资源的重新加载
2. 完成java&guava考试
3. 拍摄脱口秀视频





# 7.22 

## 工作内容

1. 学习jar包大致源码，完成作业
2. 拍摄脱口秀视频



## 心得体会

1. 实现一个东西时可以先以简单的方式实现，然后在此基础上做一些改进，比如说代码的架构，添加设计模式等
2. 当代码从阻塞或者睡眠状态苏醒过来的时候，需要再次进行判断，防止类似于虚假唤醒的情况发生



## 问题

如何简单的实现ListenableFuture与CompletableFuture之间的互换？



## 明日计划

1. 实现过期+次数一起决定单例资源的重新加载
2. 尝试更好的方式实现监听异步超时



# 7.25

## 工作内容

1. 学习mysql的线上与线下课程，整体的课程体系较为完善，学到的东西很多，例如数据类型，权限的认证，主从结构，以及对mysql的一些规范
2. 完成之前自学mysql的笔记的查缺补漏



## 心得体会

1. 了解了Qunar对于mysql使用的一些规范，例如字段设计，库表设计等，学习到了很多的知识，wiki链接如下：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=591306647 

2. 了解了mysql权限验证流程

   1. mysql将权限相关表读到内存
   2. 对连接的用户进行身份认证（从user表中获取host，user，password进行判断）
   3. 判断用户是否有数据库的操作权限
   4. 判断用户是否有对应表的操作权限
   5. 判断用户是否有对应表对应列的操作权限

   **tips**：如果有任意一个通过就不会继续往下验证了

3. INT(1)中1代表的是显示的字符宽度，而不是存储长度。这个容易混淆。

4. 索引失效的场景

   1. where条件中没有内容
   2. join中连接的字符字段类型或字符集不一致
   3. 扫描内容超过全表的20%
   4. 模糊查询以%开头
   5. 否定条件：!=, not in, not exists
   6. 对索引列进行运算
   7. 表中数据量很小
   8. 使用or关键字

5. 了解了Qunar的MySQL集群架构，如3M架构，QMHA架构，PXC架构



## 问题

建立联合索引（‘code’,  ‘age, ’name‘）后为什么`select age,name  from user where name='周杰伦';`可以走联合索引？

PXC架构中如何保证每个主机之间保持强一致性？



## 明日计划

1. 完成mysql作业
2. 阅读Joiner类的源码并记录到wiki中



# 7.26

## 工作内容

1. 完成mysql作业，对Qunar的Mysql使用规范有了进一步的了解及熟悉。
2. 阅读Joiner类源码，wiki链接如下：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=591329103



## 心得体会

1. 索引选择性可以判断一个索引是否有存在的意义。使用`show index from 表名;` 得到的Cardinality列，可查看索引选择性，Cardinality值越大表示索引越具有高选择性。
2. utf8字符集和utf8mb4字符集的区别：
   - utf8字符集的每个字符最多用3个字节进行存储；而utf8mb4字符集下的每个字符采用4个字符进行存储。
   - utf8字符集下的字段不可以存储emoj表情；而utf8mb4字符集可以。
   - 由于Mysql的单个索引存储长度最大为767字节，所以创建索引时，utf8字符集下字符串长度最多为255，而utf8mb4字符集下字符串长度最多为191。
3. 认识到了Mysql的三个日期处理函数：
   - 增加日期：date_add(date, INTERVAL n type)
   - 减少日期：date_sub(date, INTERVAL n type)
   - 两个日期的相距时间：date_diff(date1,date2) 



## 问题

1. 对于同一个类的两个方法不能同时使用是如何做到的？例如Joiner类的useForNull和SkipNulls方法不可以同时使用？
   - 这两个方法需要返回该类的对象，并且在该对象中重写这两个方法，一个方法完成具体逻辑，另一个方法则直接抛出异常，此时就可以达到调用第一个方法的时候无法调用第二个方法。
2. 对于索引及复杂sql语句的使用还不够熟练。
   - 在以后的练习或项目中多多实践，遇到疑问多跟同学老师讨论。多找几个例子进行复杂的sql语句训练，尽量少使用子查询。



## 明日计划

1. 学习redis线下课程，并做好笔记，对于不会的及时查缺补漏
2. 阅读Splitter类源码，并分享wiki



# 7.27

## 工作内容

1. 学习redis线下课
2. 阅读Splitter类源码，并分享wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=592221669
3. 完善ReentrantLock源码wiki，链接如下：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=589868021 



## 心得体会

1. ReentrantLock在加锁过程中，进入等待队列的节点会对前一个节点的waitStatus设置为SIGNAL(-1)。只有waitStatus的值小于0时才是可以正常获取到锁的节点。
2. waitStatus的含义
   - CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。
   - SIGNAL(-1)：表示后继结点在等待前一个结点的唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。
   - CONDITION(-2)：表示结点等待在Condition上（await），当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。
   - PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。
   - 0：新结点入队时的默认状态。
3. 之前我一直以为非公平是只等待队列里的所有节点都可以竞争锁，原来非公平锁的表现仅仅在于刚进来的线程可以跟第一个等待（即队列的第二个，因为第一个节点是锁对象的节点）的节点进行竞争，但队列中等待的节点都是依次被唤醒的。而公平锁是不管刚进来或者队列中的节点都是依次被唤醒的。



## 问题

ReentrantLock释放锁时唤醒下一个阻塞的线程的时候为什么要从后往前遍历呢？



## 明日计划

1. 学习java&guava作业讲解线下课
2. 学习今日redis课的ppt，理解今日老师讲解的内容，并整理成wiki
3. 如果还有空余时间，阅读Strings类源码



# 7.28

## 工作内容

1. 学习java&guava作业讲解线下课
2. 学习昨日redis课的ppt，理解今日老师讲解的内容，并整理成wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=592229513
3. 花了一个小时参与脱口秀试镜



## 心得体会

今日的学习状态不是很好，学习效率比较低，所以今天打算不加班给自己放个假休息休息，调整状态。

1. 学习到了一个对超时任务处理的类，HashedWheelTimer，其与ScheduledThreadPoolExecutor的区别是，ScheduledThreadPoolExecutor的底层时间单位是纳秒级别的，精度太高了，需要较多资源来处理定时任务。而HashedWheelTimer的时间单位比较粗糙，但足以满足一般业务的要求。
2. 实现一个程序时，需要考虑对资源的使用，例如线程，缓存，CPU等，在满足业务要求的基础上，尽量节约资源使用。
3. 对于配置的数据比较大时，可以存入到mysql中，不然如果放入zookeeper的话就很笨重，如果zookeeper挂掉之后就比较难处理。



## 问题

暂无



## 明日计划

1. 学习线上spring课程并查缺补漏，完善笔记
2. 查看mysql官方文档，解决之前覆盖索引的疑惑



# 7.29

## 工作内容

1. 学习线上spring课程
2. 完成组内分享
3. 阅读Strings源码，Wiki链接如下：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=592241728



## 心得体会

1. BeanFactory是比较原始的API，其定义DI容器的基本操作。**ApplicationContext是BeanFactory的子接口**，对其进行了许多扩展：：

   1. 继承MessageSource，支持国际化
   2. 统一的资源文件访问方式
   3. 支持加载资源配置文件

   二者区别：BeanFactory通过**懒加载**的方式注入bean，ApplicationContext是在容器启动时就**加载了全部**的bean，所以可以在容器启动时就发现存在的配置问题。

2. BeanFactory和FactoryBean区别

   - BeanFactory：是IOC容器的核心接口，在它的实现类中装载着整体的bean对象，具有完整的固定的创建bean的流程。
   - FactoryBean: 是一个bean对象，它可以自定义生产或者修饰一个bean，比如比较重型的第三方祖组件mybatis，给对象创建代理对象。

3. 面向切面编程要以**切面**为核心，分析项目中哪些功能可以用切面的形式去实现它。要合理的安排切面执行的**时间Advice**（在目标方法的前还是后）以及切面执行的**位置Pointcut**（在哪个类哪个方法中）




## 问题

今日暂无问题



## 明日计划

1. 在周末复习SSM以及SpringBoot的笔记内容
2. 简单了解HashedWheelTimer的底层实现



# 8.1

## 工作内容

1. 学习spring线下课。
2. 搭建springboot项目，由于换了环境，在搭配SringBoot项目过程中遇到了许多坑，不能完全照搬之前项目的结构。



## 心得体会

1. logback配置文件中必须存在name=root的logger节点，之前的项目也无指定name=root的的logger节点也可以直接打印控制台信息，但换了环境就不可以了。害得我以为是springboot在启动的时候卡住了。

2. 了解到spring底层一些类的具体作用：

   例如：FactoryBean:是一个bean对象，它可以自定义生产或者修饰一个bean，比如比较重型的第三方组件mybatis，给对象创建代理对象。

3. REQUEST_NEW的传播行为是采用保存点的方式来达到同个线程可以进行不同事物提交的目的。



## 问题

课后问题，如何统计Spring中bean的个数？



## 明日计划

1. 完成SpringBoot作业（写好前后端代码以及联调）
2. 理解今日老师所讲的内容，思考课后问题。



# 8.2 

## 工作内容

1. 学习spring线下课
2. 完成Spring作业，包括日志记录，部署前后端项目
3. 将前端vue项目的部署流程整理到wiki，防止日后遗忘：
4. 了解了dubbo的基本概念



## 心得体会

1. pringboot启动方式有两种：Main方法启动和外部tomcat启动。

   - 外部tomcat启动：

     - 启动类需要继承SpringBootServletInitializer类

     - 修改**pom.xml**文件，添加`<packaging>war</packaging>` 节点

     - 将内置Tomcat的作用范围修改成provided

       ```xml
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-tomcat</artifactId>
          <scope>provided</scope>
       </dependency>
       ```

2. vue项目部署流程

   1. 路由实例化中添加base属性，给路由添加项目前缀A

      ```js
      const router = new Router({
        base: '/manageSystem/',
        mode: 'history',
        routes: staticRoutes
      })
      ```

   2. 在`vue.config.js`中指定publicPath项目前缀

      ```js
      /* 部署生产环境和开发环境下的URL：可对当前环境进行区分，baseUrl 从 Vue CLI 3.3 起已弃用，要使用publicPath */
      publicPath: '/manageSystem/',
      ```

   3. 使用命令`npm run build`构建一下项目，生成dist文件夹

   4. 将该文件夹放到tomcat的webapps下，并重命名为项目的名称A（需要与第一步的项目前缀一致）

   5. 通过访问`localhost:端口/项目名/` 的形式访问



## 问题

tomcat控制台出现乱码

解决：首先修改server.xml文件的Connector节点 **新增** `URIEncoding="UTF-8"`。然后在logging.properties的java.util.logging.ConsoleHandler.encoding的值改成GBK。



## 明日计划

1. 学习dubbo内容并记录到笔记中
2. 参加脱口秀培训以及Qunar PostgreSQL开发指南



# 8.3

## 工作内容

1. 学习dubbo与spring/springboot的整合
2. 参加脱口秀培训以及Qunar PostgreSQL线下课
3. 完善spring作业并提交



## 心得体会

1. pgsql有丰富的数据类型，可以很好的记录地理信息以及其他常用且结构较为复杂的数据。但对应而来的sql操作也较多较复杂。
2. 了解到了物化视图的含义：视图是一个虚拟表，并不是真实存在的，且数据并不是持久化的。但物化视图是可以将数据持久化的视图。那物化视图该如何保证数据的正确性呢？pgsql的解决方法是在数据发生改变时接受一个信号，然后对物化视图的数据进行更新。



## 问题

感觉对数据校验的方式不是很规范，等老师讲作业的时候学习或者向老师提问更好的数据校验方式。



## 明日计划

1. 搭建zk注册中心
2. 完成spring考试（使用dubbo完成RPC服务调用）
3. 有剩余时间学习dubbo底层调用原理



# 8.4

## 工作内容

1. 跟着尚硅谷视频学习了dubbo的基本使用，一些属性参数的含义以及学习了dubbo整合spring和springboot。并将其整理成wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=594424959
2. 搭建zk注册中心到服务器
3. 使用Springboot整合dubbo完成RPC服务调用：对整体项目进行分包，分别创建公共模块、消费者服务以及提供者服务，在消费者服务中提供对外的增改查接口，在提供者服务中对h2数据库进行增改查操作。使用注解的方式完成远程服务调用。



## 心得体会

1. H2是个内存数据库，整合Springboot的时候可以不需要安装，直接添加依赖，编写简单配置后即可使用。因为是个内存数据库，所以当程序重启的时候该数据库中的数据也会消失。而创建表的语句可以放在资源文件中，在程序启动时可以自动创建表结构。
2. 在RPC调用远程服务的时候，如果需要传递对象，需要将该对象序列化，在SpringBoot项目中会自动进行序列化，前提时我们需要让该类实现Serializable接口。
3. 



## 问题

在基础RPC的基础上，实现异步的调用。在异步调用的时候前端会出现报错，这个问题待明日研究。

在什么时候需要使用异步调用远程服务呢？



## 明日计划

1. 进一步学习dubbo底层调用的原理
2. 根据所学知识以及参考网上文章对今日的RPC调用进行异步化
3. 学习mybatis线上课程



# 8.5

## 工作内容

1. 完成了dubbo远程服务的异步调用，在中间遇到了版本的坑，最后决定使用低版本的注解的方式实现（在async参数设置为true）,但此方式会让该服务的所有方法都变成异步。
2. 学习了mybatis的线上课程，复习了之前学习myabtis的基础知识，并了解了公司的mybatis公共包meerkat-mybatis，并整理成wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=594430621



## 心得体会

1. 当RPC异步调用时，原先方法的返回结果会全部变成void，需要用future的get等方法才可以获取到结果。

2. mybatis使用的时逻辑分页。逻辑分页和物理分页的区别：

   1. 逻辑分页：数据库返回的不是分页结果，而是全部数据，然后再由程序员通过代码获取分页数据。
   2. 物理分页：数据库返回的直接就是分页后的结果。比如mysql的sql语句中使用limit。

   两者的对比：

   1. 数据库负担：物理分页每次都访问数据库，逻辑分页只访问一次数据库，所以物理分页对数据库造成的负担大。
   2. 内存负担：逻辑分页一次性将数据读取到内存，占用了较大的内容空间，物理分页每次只读取一部分数据，占用内存空间较小。
   3. 实时性：逻辑分页一次性将数据读取到内存，数据发生改变，数据库的最新状态不能实时反映到操作中，实时性差。物理分页每次需要数据时都访问数据库，能够获取数据库的最新状态，实时性强。
   4. 适用场合：逻辑分页主要用于数据量不大、数据稳定的场合，物理分页主要用于数据量较大、更新频繁的场合。



## 问题

在同步代码中，使用AOP对方法进行统计运行时长，在before中记录起始时间，在after中计算运行时长，会不会出现线程1执行完before后被线程2抢占执行after？

答：是不会有这种情况的。因为AOP的所有切面会跟原方法形成一个执行链，而这个执行链是通过递归的方式执行的，所以不会出现同个方法的before跟after被不同线程执行。





# 8.8

## 工作内容

1. 学习Mybatis入门教程线下课，帮助自己复习了mybatis的基础知识，并且了解到了plugins、handler的意义，以及如何自定义plugins和handler，自定义plugins和handler之后不要忘记在全局配置文件中注册。
2. 学习工程规范，学习了maven的相关内容以及版本管理。对于maven的版本管理，如当要解决版本冲突时，尽量不要使用排除的方式，而是在依赖管理的标签中指定版本。在父子工程时，在父工程中指定版本，在子工程中引入依赖。
3. 了解到了`<trim>`标签的使用，个人感觉其使用可以更加的灵活，可以自定义要添加的前缀后缀，也可以自定义要删除的前缀后缀，对于动态sql的使用更加的灵活了。
4. 统计了一个基本的spring项目的bean的个数。创建一个类实现BeanFactoryPostProcessor，重写postProcessBeanFactory方法。利用postProcessBeanFactory方法中的参数configurableListableBeanFactory进行统计。



## 心得体会

1. mybatisPlus也是根据拦截器来进行实现的，类似于Spring的AOP，在mybatis基本功能的基础上进行其扩展的操作。
2. 在进行批量插入或者批量查询的时候，使用`<foreach>`标签的效率会比for循环一个个操作的效率高的多。
3. 一个基础的spring项目包含的bean个数为3个。分别为：environment、systemProperties、systemEnvironment。
4. configurableListableBeanFactory的方法使用：
   - `getBeanDefinitionCount()`：只能获取**自定义**的bean个数
   - `getBeanNamesIterator()`：可以获取**所有**的bean的名字
   - `getSingletonCount()`：可以获得单例bean的数量



## 问题

- dubbo目前是最新版本的异步也是future返回吗，还没有支持compleableFuture吗？
  - 2.7版本的dubbo的所有异步编程接口开始以 CompletableFuture 为基础。

- 切面的实现使用的是哪种方式的代理(例如jdk的cglib的等等)
  - 都有使用到。如果是接口则使用jdk的动态代理，否则使用cglib代理。

- 是编译期完成的代理还是运行期完成的代理
  - AOP 代理可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，在编译期间完成。而动态代理（jdk跟cglib）都是在运行期完成的。



# 8.9

## 工作内容

1. 完成mybstis作业。搭建单纯的maven项目，引入mybatis的jar包，然后通过sqlSession对数据库进行操作，有利于复习mybatis的基础知识。
2. 查阅有关于AOP的相关资料，其实现方式有两种，分别为 静态代理 和 动态代理。静态代理 主要是 AspectJ，动态代理 主要是 Spring AOP（jdk和cjlib）。
3. 参加脱口秀彩排及改稿。
4. 学习服务通信协议线下课。了解到了HTTP协议与dubbo协议的对比，Jackson的使用。

- - HTTP是用于用户对公司的服务进行访问的，而RPC是用于公司内部服务间的调用，RPC相对HTTP主要就是减小消息内容，提高序列化反序列化的速度，从而提高性能，另外dubbo还具有服务治理等功能
  - dubbo底层传输协议也是tcp，但是可以在服务发现时与每个provider都事先建立一个长连接，这样就能减少tcp连接和断开的损耗。



## 心得体会

1. AOP的实现主要有两种，分别为 静态代理 和 动态代理。静态代理 主要是 AspectJ，动态代理 主要是 Spring AOP（jdk和cjlib）。
2. 静态代理 是在编译期就完成织入操作的，而动态代理是在运行期完成织入的。静态代理需要自己去编写代理类代码，在AspectJ中有特定语言编写切面，但在编译期间会修改原先类的字节码，从而形成代理对象。而动态代理不需要自己代理类，也不会去修改字节码，而是程序运行后在内存中临时为方法生成一个代理对象，这个代理对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。



## 问题

Aspectj和Spring AOP有什么不同？

- Aspectj不受类的特殊限制,不管方法是private、或者static、或者final的,都可以代理。而Spring AOP不能代理private修饰的方法
- 编译期织入比运行期织入的性能更高，但是需要特定的编译器进行处理。
- Aspectj不适合用于大型项目，因为需要自行为每个类编写增强逻辑代码，耦合度高。但其可以对目标类的每个方法都做不同的处理，进行更细致的处理。



# 8.10 

## 工作内容

1. 复习前几天课程的ppt内容
2. 学习Qunar运维工具使用课程，对公司的运维工具进行基本的认识，比如bistoury查看日志，watcher监控指标，Qtracer链路跟踪系统。了解了对于经典问题的时候的排查步骤。
3. 比如cpu利用率飙高, CPU利用率飙高可能的原因:请求量增加、IO问题、死循环、频繁的gc.此时可以通过如下步骤进行问题定位: (也可以通过**Bistoury**平台进行分析)
   - top命令找到占用cpu高的进程号，看是否为java进程 
   - `su tomcat 切换用户`或`sudo –u tomcat指定用户运行` 
   - `jstack $pid > jstack.txt dump java进程的线程栈 ` 
   - `top -Hp $pid` 找到对应的线程号
   - 根据线程号(需要转为16进制)到jstack.txt中找到对应的调用栈
   - 分析调用栈



## 心得体会

1. Bistoury平台可以用于java进出引起的主机CPU、load、内存飚高的问题排查，也可以用于日志实时查看，还可以用于调试。
   - **watch命令**能方便的观察到指定方法的调用情况（比如参数信息，返回值）：`watch 类全路径名 ipToAppCode {params,returnObj} -x 10` (只能观察不能记录)
   - **tt命令**除了能够**记录**指定方法的参数信 息外，还能重新执行一次记录下来的调用：`tt -t -n 3 类全路径名 ipToAppCode` （**-t** 这个参数的表明希望记录下方法的调用情况， **-n**用于指定记录的次数，防止内存被撑爆）
   - `tt –i index`可以重新调用一次index位置的方法 



## 问题

问题1： bistoury如何检测死锁

解决： 检测死锁的方式可以通过IDEA的控制台输入jps -l（相当于Linux 的ps -ef），得到进程号，然后输入jstack 进程号来查看死锁情况；也可以通过jconsole Java监控和管理控制台来查看死锁情况。猜测bistoury的底层实现应该也是这种方法



# 8.11

## 工作内容

1. 学习网络安全相关知识，并记录成wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=596142980
2. 参加小组的技术分享：线程池的源码解析，completetableFuture的源码解析，redis的数据结构。这三个模块都是在自己知识之外的，需要找时间补一补。
3. 参加脱口秀彩排及背稿。
4. 学习和了解了使用外部tomcat运行SpringBoot项目时的大致原理及流程，wiki链接如下：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=597005458



## 心得体会

1. 原来还有很多工具可以修改或模拟设备的信息，从而来获得黑产。另外平时用于调试的工具也可能成为黑客的使用工具，例如postman和fiddle。
2. 渐进式hash的含义：在hash表进行扩容的时候，不会对所有的元素进行重新计算hash并移动到对应的位置，而是每次对table的操作（get、put等）都会移动一小部分的元素。这样可以减少一次扩容的消耗时间。
3. 为了可以不使用web.xml，servlet提供过了的`ServletContainerInitializer`接口，通过实现WebApplicationInitializer，在其中可以添加servlet，listener等，它通过SPI机制，当启动web容器的时候，会自动到项目所有jar包下找到`META-INF/services`下以**ServletContainerInitializer**的全路径名称命名的文件，它的内容是ServletContainerInitializer实现类的全路径，然后容器根据全路径名称将它们实例化。例如Spring项目启动时会加载spring-web的`META-INF/services`下的ServletContainerInitializer的实现类。这也是为什么SpringBoot项目要引入spring-web依赖的原因。



## 问题

tomcat会加载所有WebApplicationInitializer的实现类，并回调他们的onStartup方法，那使用SpringBoot项目时，该使用SpringBootServletInitializer的onStartup方法还是AbstractDispatcherServletInitializer的onStartup方法来创建Spring容器？

目前知道的是，WebApplicationInitializer所有的实现类会放在list中进行order值升序排序后，依次执行。SpringBootServletInitializer的order值是最小的，会先执行，但是还没看到Spring的order值，这个问题明天会继续研究。



# 8.12

## 工作内容

1. 学习spring作业讲解课，学习了许多实践项目的经验，例如：
   - 如何判断db操作是否成功？ 一般情况下不出现异常默认成功，有特殊需求看生效行数。
   - JSR303进行数据校验，简化代码。
   - 不能用一个简单实体类来贯穿整个业务流程，需要细化成 VO、DTO、DO、PO。VO是用来接受前端页面传递的参数，DTO主要用来Controller层向Service层传递数据，DO就是从现实世界中抽象出来的有形或无形的业务实体，主要有一些业务方法的调用，PO持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系。
2. 参加脱口秀彩排以及表演脱口秀
3. 学习如何自定义类型处理器，继承BaseTypeHandler类，然后在配置文件中指定。



## 心得体会

1. 在给表里的数据添加默认值时，一般需要添加与正常逻辑不太符合的值。
2. 在进行深度分页的时候可以添加查询条件，比如让用户选择一定时间内的数据再进行分页，或者以上次查询的最大id作为下一次的查询的参数，以减少查询的数据量从而提高查找效率。
3. 在JSR303检验中，如果对于不同的场景需要对同一个属性进行不同的检验，那么可以在使用注解的时候指定group属性。
4. 学习设计模式的时候不能每次只单单关注那一个模式，应该进行横向对比，比较着学习，这样效率会比较高。



# 8.15

## 工作内容

1. 学习大数据平台线下课。了解到了KVM以及docker的区别、离线日志和实时日志的区别

2. 学习DEVOPS线下课。了解到了开发前项目的申请，以及开发时的一些规范。

   - 测试环境 - NOAH

   - 自动化测试平台 - 灭霸

   - 线上发布 - Portal

   - 在线debug地址：http://bistoury.corp.qunar.com/debug.html 

   - 动态监控地址：http://bistoury.corp.qunar.com/machine.html 

   - 添加监控需要添加jar包

     ```xml
     <dependency>
         <groupId>com.qunar.flight</groupId>
         <artifactId>qmonitor</artifactId> 	
         <version>${qmonitor.version}</version>
     </dependency>
     ```

3. 了解dubbo的底层原理（标签解析跟服务暴露部分），流程链接：https://www.processon.com/view/link/62fa3b4c1efad4229fa66f89

4. 复习了ThreadLocal源码，wiki链接：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=597550227



## 心得体会

1. KVM以及docker的区别
   - KVM的机器上的日志无限制保留，需要手动删除。而docker机器上日志只保留1个小时，过期删除
   - KVM的日志收集需要申请；而docker的日志自动收集
   - KVM的离线日志有天日志和小时日志的区别：名称时`%Y-%m-%d`的为天日志，名称是`%Y-%m-%d-%H`的为小时日志。
2. **离线日志**的延迟高（一般是30分钟左右），主要用于日志备份（保存时间可自定义），查看途径是使用**goldeye**。**实时日志**的延迟低（一般是秒级别），主要用于即时查找线上问题（保存时间为7天），查看途径是使用**jinkela**。
3. 开发的时候分支命名规范：`JIRA编号_YYYYMMDD_DESC`，例如`HOTELRM-888_20140929_BlankPage` 



## 问题

dubbo在哪些方面是存在不足的呢？

1. dubbo只支持java，对于其他语言是不支持的
2. dubbo的jar包依赖是比较头疼的



# 8.16

## 工作内容

1. 学习需求分析和软件设计线下课。了解到需求分析大致分为四步：需求idea、需求RDQA、需求估时（1pd=8小时）、需求FR。在需求RDQA阶段，需要跟产品明确好需求功能，并记录下来，便于日后有迹可循。
2. 了解dubbo服务引用以及服务调用的流程，并进行整理。了解到了RPC调用的流程，以及zookeeper作为dubbo注册中心的作用：当有服务变更时会及时的通知dubbo更改，以及zookeeper可以进行集群和强一致性，提高了注册中心的高可用。



## 心得体会

1. 涉及流程改动时需要有相关流程图、现状流程图和完整闭合的交互、清晰的外部系统依赖。
2. 涉及页面改动时要有原型图、有UI设计图、确定是否版控。
3. 软件可靠性考虑：监控，埋点和验证方案、新旧逻辑处理、性能和安全考虑
4. Dubbo的配置是基于 Spring自定义标签扩展 实现的，例如dubbo:service、dubbo:reference等。Spring在解析到自定义的namespace标签时，会查找对应jar包的`META-INF`下的`spring.schemas`和`spring.handlers`文件。**spring.schemas**作用是让Spring优先加载指定的xsd文件。其次**Spring.handlers**文件中配置了xsd命名空间与对应的处理器的匹配关系，让XXXNameSpaceHandler和XXX.xsd关联到了一起。最后XXXNameSpaceHandler代码内部绑定了和XXXBeanDefinitionParser的关系。
5. RPC调用实际是开启服务器监听指定端口，然后客户端连接上指定端口，然后以此进行通信。



## 问题

dubbo本地使用了ConcurrentHashMap作为注册表，来存储服务地址与服务功能的映射，为什么还要用zookeeper存储？

ConcurrentHashMap只能保存到本地，当注册表需要变更时只能通过修改配置文件、重启服务的方式更新，使用zookeeper可以及时更新，且zookeeper可以保证高可用。



# 8.17

## 工作内容

1. 上午参与项目启动会&需求文档的线下课程，了解了项目安排、项目分组、项目的关键时间节点等
2. 下午与新的项目小组、项目导师开了项目组会，跟需求方确认需求，了解了一些机票的基础知识，例如生单，ota的含义。
3. 与相同模块的成员一起讨论功能需求
4. 记录整理需求中遇到的问题



## 心得体会

1. 学习了流程优先级的定义，P1是最高级，接着是P2、P3、P4。确定项目计划时的排期节奏和排期范围，通过仪表板的systemdashboard查看需要关注的任务。
2. 项目期间需要注意的问题有：监控报警，监控加的不合理，不全面，异常没有区分，没有设置报警；checklist 设计不合理，粒度太粗，缺乏可执行性；对 code diff 参与度不够，并且没有将 code diff 过程记录下来等。



## 明日计划

1. 梳理流程图，整理出不会/不理解的部分，并想成员或老师提问，解决问题
2. 灭霸了解使用
3. 明确项目的需求，并确定好模块的详细功能



项目流程图中有很多专有名词不了解其含义，对许多的功能要求不理解，明日在项目导师来开会的时候进行提问，解决我今日所记录的问题。





# 8.18

## 工作内容

1. 上午项目小组之间互相讨论项目需求、每个环节的具体需求以及实现思路。
2. 下午2点到4点，学习项目实施注意事项线下课。
3. 下午跟项目导师一起开会答疑，主要是重新解释整个项目流程以及需求，对每个流程的具体细节进行讲解。目前明白了导师大致的需求想法。



## 心得体会

1. 发布项目前后都需要注意一些事情。发布前应该检查发布权限、梳理模块上下游系统依赖、 确认发布步骤、确认回滚步骤；发布时应该按照发布顺序发布、QA查看监控- 观察半小时以上，开发查看日志 -观察半小时以上、发现问题马上按照回滚步骤回滚、及时申报故障。
2. 没有明确的需求文档，感觉开发很难开始进行。
3. 不同环境下同一流程的diff不仅仅要比较流程中每一步的结果，还要比较有关联关系步骤的结果，比如ota页选购了保险，在订单详情页也要有对应结果（中间经历了booking阶段），才能进一步保证下流信息的不丢失。



## 问题

最终一致性跟强一致性的区别？

强一致性可以保证从库有与主库一致的数据。如果主库突然宕机，我们仍可以保证数据完整。但如果从库宕机或网络阻塞，主库就无法完成写入操作。

最终一致性在某一时刻用户在不同的从库查询到的数据可能不同，但是最终成功更新的数据都会被所有用户或者进程查询到。zookeeper采用的就是最终一致性。



## 明日计划

1. 了解规则引擎
2. 针对导师给的需求文档进行明确分工和细化模块功能
3. 学习测试相关的线上课



# 8.18

## 工作内容

1. 早上进行简单站会讲解昨日各自对于各自负责的模块的一些理解。在整理好整体的疑问之后需求导师开会，让需求导师帮忙答疑。
2. 由于在下午梳理需求实现细节的时候前面两个模块出现了一些歧义，在全组讨论了一小时后选择让需求导师解答歧义。经过这次会议之后基本明确了整体功能的需求以及一些需要注意的点。
3. 临下班前学习了测试相关的线上课。学习了checklist和case的生命周期，主要有创建、设计和执行，以及一个Bug的生命周期，学习使用checklist平台和case管理平台，了解case的执行人和执行环境：测试环境、仿真环境、灰度环境和线上环境。
4. 由于时间原因还未完成了解规则引擎，明日将花时间了解。



## 心得体会

1. 在对需求有歧义的时候，应该跟同组的同事一起讨论，如果没有讨论出结果应该及时跟需求方确认，以免自己盲目的猜。
2. 对于功能需求，不能只明确自己负责的模块，还应该了解不同模块以及整体的流程，便于沟通和更好的配合。
3. 公司有许多的方便的图形化界面使用平台（如灭霸，发布，申请资源等），每个平台的使用感觉都需要花一定的时间去了解。可能通过此次的项目开发可以帮助我大致了解这些平台的时候。



## 问题

在diff的时候需要读取qconfig配置来判断哪些参数之间是需要进行diff的，该如何实现这个配置，并且读取解析？

计划先了解一下qconfig的使用，然后试着跟参数配置进行挂钩。



# 8.22

## 工作内容

1. 上午拆分了diff模块的需求拆分和大致估时。
2. 拆分需求后对规则引擎的概念进行了了解。规则引擎是一个将规则验证代码跟业务代码中拆开的组件，它可以使规则变得可配置化，更加的动态，并且与业务代码解耦合。常见的规则引擎有drools，Easy Rules等。
3. 下午2点到4点学习checklist&测试用例的设计。
4. 下午5点到6点，了解了QConfig的相关概念和基本使用。
5. 下午6点至7点，与项目组需求方进行开会，听需求方讲解已有项目（linker）的主要代码结构和功能。
6. 晚上8点至8点半，学习noah线上课。



## 心得体会

1. 机票项目专业名词。t值：用于形成唯一url，标识页面，例如`http://qunar.com/fca?qrt=f_flight_rn_domestic_flightlist`。c参：通用参数。b参：业务参数。
2. 系统每次处理请求都会生成一条唯一的traceId，在主流程中，每个请求都会记录下前置请求的traceId，我们可以用最后一个请求的前置traceId串起一次下单的所有关键数据。订单详情请求根据订单号获取，其他流程的请求根据traceId获取。
3. 用户在生单到支付的过程中，有15分钟内支付的限制，再算上搜索机票和选择报价的时间，可以粗略的认为用户的一次下单行为操作时间会集中在2个小时内。所以一般会缓存下这2小时内的所有关键数据日志。



## 问题

什么是下单快照？有什么用？

下单快照就是用户在下单过程中看到的数据的快照，即用户在一次下单流程中涉及到的所有页面数据的快照集合。下单快照主要是用于回放用户真实看到的数据。



# 8.23

## 工作内容

1. 细分需求拆分。由于昨日的需求拆分的还不够细致，所以今天进一步拆分，然后做成表格提交给需求方检查。
1. 在数据库设计之前需要先画好ER图，所以先与组内成员一起画ER图，确认每个表之前的关系与表的字段。目前针对diff流程与结果展示流程设计了3张表，第一个表记录执行diff的场景和PMO，第二张表记录场景下每个流程具体的diff信息，第三张表帮助辅助diff信息的完善。https://www.processon.com/view/link/630487e10e3e7437cac86f44
1. 针对上午设计的ER图，编写详细表格解释每个字段的含义以及对应的类型。
1. 与组内成员一起设计diff流程图，并与其他模块的成员一起整合，形成整个项目的流程图：https://www.processon.com/view/link/6304b2c37d9c0808a2e49198



## 心得体会

1. 与同事交谈过后，发现qconfig-admin是后台系统，qconfig-server是服务端，用户在后台系统修改配置文件之后会通知server端进行变更。而server端会在本地缓存保存文件内容，并且每隔三分钟将缓存中的文件内容更新到数据库中。
1. 在进行一个项目的时候，不能基于去代码实现，需要先做好设计。比如说进行数据库设计之前，需要先调研然后画好ER图，画好ER图之后才进行数据库设计，在数据库设计好且对技术方案设计好之后，最后才编写代码实现功能。



## 问题

今日听到，在某些场景下，为了提高查询效率，不得不使得表变的冗余一点，以空间换时间。例如有四个字段：A,B,C,D，BC之间是多对多的关系，CD之间是一对一的关系，而BC是需要经常根据A查询的字段，此时为了效率还需要把BC单独放在一张表吗。

在diff流程中，有两个diff方式，一个是流程diff，一个是前后diff，这两种diff大部分字段是一样的，只有个别字段是需要单独拥有的。由于需要记录两个diff的详细过程，在设计数据库表的时候，是需要两个表才存这两个diff详情呢还是使用一个表来存这两个diff详情，然后使用type字段来区别diff的方式。这两个方式哪一个比较好呢。



## 明日计划

1. 根据需求方的建议修改er图和流程图。
2. 如果需求方任何er图跟流程图之后，尝试规定qconfig相关配置和解析。
2. 对diff流程进行方案调研。





# 8.24

## 工作内容

1. 了解Qconfig使用。在Qunar提供的脚手架中创建一个空项目，添加QConfig依赖，按照QConfig的wiki使用文档，对QConfig进行实践使用。
2. 跟功能模块导师开会，确认需求拆分以及估时。此过程中导师让我们需要对功能点描述的更加清楚一点，比如QConfig配置规则，需要描述QConfig需要包含哪些字段，这些字段的含义等。
3. 需求方对于diff流程图没有争议，但需要我们实现好数据库字段，所以下午根据ER图进行了每个表的字段设计，包括字段名，类型，描述。



## 心得体会

1. QConfig为了方便测试，可以在本地项目的resources/qconfig_test/以项目名为文件名的文件夹下创建QConfig配置文件，然后在项目中就可以进行使用。如：

   ```java
   @QMapConfig("test.properties")
   private Person person;
   ```

2. 对于 diff 过程表，并不是每一个 case 都要进行流程diff 和前后diff，可能只需要进行其中一种diff。结合昨天的日报问题的第二个问题，从扩展性、健壮性、性能等角度考虑，觉得分为两个表会更好。



## 问题

1. 是否需要执行前后diff跟流程diff是不固定的，需要根据用户的意愿来选择，该如何实现？

在QConfig中新增两个配置选项来标识是否需要前后diff或者流程diff。



## 明日计划

1. 画甘特图
2. 对负责的diff进行接口，方案等设计



# 8.25

## 工作内容

1. 根据昨日需求拆分后的估时进行甘特图的绘制。接着进行接口设计，根据自己负责的功能模块，设计好与外部对接的接口所需要的请求参数和返回结果，将其形成wiki，方便其他成员查看。
1. 与相关联的成员一起过一遍大家的接口设计，尝试的串联功能，查看各自接口的设计是否有出入。比如说执行时间，可以第二个模块传递过来，也可以在第三模块对应接口中第一行代码就记录时间，虽然有一点点小小的误差，但是不影响数据严谨，所以说可以不用传递执行时间参数。
1. 在整体模块讨论过程中，逐渐发现各自负责功能可能出现的缺陷，但此缺陷需要关联其他模块，大家一起商讨解决方案。比如用户有意无意连续点击执行按钮时，会出现重新diff的情况（上一步的diff还没结束接着又请求diff）。此时需要前端加个提示框，确认用户是否真的要执行，且此时后端需要进行增量插入的方式记录diff过程。
1. 了解QConfig的使用，以及设计QConfig中定义前后diff的相关配置。



## 心得体会

1. @QConfig、@QMapConfig和@QTableConfig注解都会在配置文件发生变更后去config获取最新值。
2. 学习了 QConfig 自定义分隔符。 对于注解 @QMapConfig，字段为List、Set或数组时，默认分隔符是英文逗号“,”，可以使用 collectionSeparator 属性指定分隔符。字段为Map时，默认用英文冒号":"分隔key value，用英文分号';'分隔key value对，mapSeparator属性指定map的分割符。



## 问题

在使用@QMapConfig注解自定义分隔符时，没有像使用文档里的collectionSeparator和mapSeparator属性。

解决方案：在使用脚手架生成的QConfig项目中的版本并不是最新的，而@QMapConfig注解的collectionSeparator和mapSeparator属性需要2.0.6版本才可以使用。





# 8.26

## 学习与收获

1. 接口流程数据推演。上午全组成员根据昨日接口的设计进行串联，尝试跑通整个流程，防止接口遗漏接收参数或者返回结果漏传递数据。
2. 与模块导师确认需求估时和功能技术设计方案可行性，在讨论过程中导师建议异常不需要监控，只需要打日志，因为此项目作为工具使用，不需要进行监控，当出现错误时可以查找到原因即可。
3. 刁洪亮师兄讲解项目分包结构。我们在已有的linker项目中进行开发，每个模块在对应的包下进行实现，如果需要依赖其他模块，需要其他模块在rpc包下暴露接口，在impl下实现该接口。
4. 学习了QDoc的使用（主要包括接口，实体类，返回值注解的使用），个人感觉跟swagger-ui差不多，只不过QDoc可以在全流程中使用。



# 8.29

## 学习与收获

1. 编写QConfig的前后流程配置以及解析的技术方案，具体到数据结构，具体技术的设计，以及绘画了单接口流程图（带泳道）。泳道针对的是不同系统之间有接口调用的流程，每个泳道表示每个系统。
2. 在项目中定义基本的接口和QConfig相关数据结构的设计，并使用QDoc来添加详细信息，利于文档的查看。
3. 学习测试工具使用线上课。
   - cm：potral（可用于应用管理、部署环境、进行回滚/上线/下线/重启和持续交付等），noah，mock。
   - ops：or管理平台（查询负载均衡配置），故障处理平台。
   - DBA: dubai，sql审核，web sql。
   - TCDEV: qtrace追踪，异常日志平台，运维事件平台。



## 问题

今天主要的时间都在处理QDoc文档的问题。在编译QDoc的时候，一直出不来QDoc文档链接，换了maven版本以及重新拉取项目也行不通。原因是拉取项目的时候没有使用ssh的方式拉取项目。好像公司里拉取远程仓库都需要使用ssh的方式，而不能使用HTTP的方式，否则会找不到git路径。



# 8.30

## 学习与收获

1. 根据需求方的要求，在数据库设计中给每个表都加上了”记录操作人“字段，但由于我们目前没有操作人的标识（登陆操作），所以此字段打算默认为system即系统操作，然后如果需求方日后对此项目迭代的话再自行更新此字段。
2. 修改QConfig配置文件的内容格式。尽量使用可视的表达方式做规则，比如：json格式，有明确的定义；不要使用各种自定义格式，基本无法理解，使用者每个人都是学习成本。所以从一开始的properties文件改为json文件，但是从而带来的是需要修改解析QConfig的设计（目前正在设计中，因为有比较多的嵌套，不太好解析）
3. 参加下午的生日会以及联调&发布学习线上课。



## 问题

在使用QConfig获取json文件时，好像无法获取到比较多层嵌套的数据，例如：`Map<String, DiffConfig>，其中DiffConfig有个属性是List<Procedure>` 。目前还在研究如何将json嵌套中的数组的内容解析到List中。



# 8.31

## 学习与收获

1. 重新设计QConfig配置内容的格式。为了可视表达，选择使用json格式的配置文件。在定义好配置文件格式的基础上，设计数据结构来接收配置文件的内容。
2. 修改数据库设计中的某些字段，确定好建表语句并跟导师确认无误之后在测试环境中建表。首先在测试库建表可以在本地使用navicat连接，然后对数据库进行操作，但前提是需要知道数据库连接的相关信息。这些信息可以在noah环境的数据库配置中的环境变量中查看到。
3. 对之前自己对于QConfig的学习进行一些整理（由于之间关系还没有完善好）：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=604308595



## 问题

使用@JsonProperties注解对json的key值进行下划线转成驼峰时，需要结合@Data可以才可以获取到值。如果手动实现getter、setter的话是获取不到的？

原因是@Data更加智能一点，如果在属性上添加了@JsonProperties注解，在编译时会自动在对应的setter方法上加上@JsonProperties注解。



# 9.1

## 学习与收获

1. 今日主要任务是进入coding阶段。在经过了之前将近半个月的需求分析，方案设计，今天正式开始写项目代码，首先是为前后diff接口进行了简单的实现，先搭建好大致的逻辑代码结构，具体的实现方式（例如参数解析）还有一些需要异常处理的地方使用Todo方式先记录下来。其次是实现了调用其他服务的工具类，将参数封装json格式放入请求体中，然后发送post请求。
2. 学习监控线下课程，主要学习到监控的意义，如何添加在项目中监控以及查看及配置监控面板和报警。我感觉监控的作用就是为了出现问题时公司可以第一时间的发现，尽量将风险最小化。
2. vo不仅可以作为前后端交互的传输对象，还可以作为不同模块之间交互的传输对象。但是内部方法交互时的数据传输对象不知道该放哪个包比较好。



## 问题

 由于进行有些方法（自己内部的方法调用）的参数过多，我想把这些参数抽成一个类，但是不知道这个类应该放在哪个包下，最终我将它放在bo包下。我想问下导师的看法。



# 9.2

## 学习与收获

今日主要是修改获取QConfig配置文件的方式以及跟项目导师寻求项目问题的解决方案。

1. 上午在尝试使用原生API的方式获取QConfig配置文件内容，但跟项目导师沟通后得知，原先项目获取QConfig配置文件内容是通过注解的方式，交给spring统一管理，因此重新修改代码采用注解的方式获取QConfig配置文件。在此过程中学习到了，在一个配置类中，内部的属性最好不要暴露给外部，仅仅通过get方法来提供给外部使用，这样可以保证内部属性的安全性。
2. 下午跟项目导师寻求项目的一些疑问的解决方案。例如：
   1. QConfig配置在tc的dev环境中创建了，为什么在本地运行还是获取不到？
   2. 项目如何在pmo环境中部署，以及部署之后可以在http://portal.corp.qunar.com/applist/appList.html中搜索并查看到本项目的ip地址。





## 问题

QConfig配置在tc的dev环境中创建了，为什么在本地运行还是获取不到？

一般写完代码要测试的是现在本地运行，本地运行没有报错的话再部署到bate环境中，然后再bate环境测试功能。尽量不要在本地去测试，因为很多环境配置本地都没有需要手动配置，比较麻烦。

在跟项目导师讨论一个小需求的时候，导师说没有必要为了一个记录case数量根据数量得出case的运行状态的小需求，从而加一个表。但是不加表，实现逻辑就比较复杂，表中可能会增加许多无用记录且效率变低，代码逻辑也有比较大的改动。这种情况想问下导师是加表比较好，还是改逻辑比较好。





# 9.5

## 学习与收获

1. 今日主要是实现上周留下的功能具体实现逻辑，日志记录以及异常处理。实现代码之后merge其他模块的代码，解决冲突。由于原有项目的存在的问题，导致项目在bate环境中始终启动不成功，目前正在等待原有项目人员解决此问题后进行线上的功能测试。
2. 学习线上的codediff课程。了解到了要在什么时候进行code diff：
   1. 提测试code diff：得到本次代码的改动范围，使用branch代码与master代码进行全量diff；
   2. 改bug后code diff：确认开发代码的提交量、测试的回归量，使用修改前后打出的btag进行增量diff；
   3. 发布后code diff：确保本次发布的代码和测试的代码一致，使用测试通过的btag与master代码进行全量diff；
   4. merge后code diff，确保没有代码丢失、分支merge错等问题，使用merge前后的两个btag增量diff/分支与master代码进行全量diff。



## 问题

今天主要问题是项目部署到bate环境时一直失败。因为之前旧项目的遗留问题，一个是数据源，一个是kfk问题，所以测试环境一直部署不上，我们也无能为力，只能等之前的人员处理完之后才能进行部署测试。



# 9.6

## 学习与心得

1. 完成了项目的bate环境部署，并测试了线上的QConfig配置文件获取，感受到了部署成功的喜悦。在部署项目到bate环境后，可以登陆机器然后输入`cat logs/error.log` 命令查看错误日志。部署成功后可以在protal平台选择对应环境查看具体机器的ip。
2. mock数据进行调试。根据第二模块提供的大致的数据内容进行mock，然后对项目进行debug尝试跑通diff流程。发现一些bug，如String的判空应该使用isBrank更好一点；更新时间不要忘记手动传参；对jsonPath依赖的方法应该加一个trycatch，防止出错但无提示。



## 明日计划

1. 对今日mock数据跑通diff流程时遗留的bug进行修复。
2. 跟其他模块进行串联调试。



## 问题

1. 在dao插入数据时报 There is no getter for property named 'around_diff_id' in XXXClass 错误。我在该类使用了@Data注解，以及在xml中数据库字段名跟实体类的属性名都没有拼错，不知道这个错误是如何产生的，明日再进行排查。





# 9.7

## 学习与收获

1. 解决昨日在dao插入数据时报 There is no getter for property named 'around_diff_id' in XXXClass 错误。原因是xml的if标签中的around_diff_id没有写成驼峰的方式，只有数据库字段才是下划线的方式，其他地方都应该使用实体类属性。
2. 学习故障管理线下课，有以下心得：
   1. 在出现故障时，第一时间不应该花大量的时间去找原因所在，而是先大致判断原因，然后第一时间回滚线上代码或者停用故障功能，避免造成更大的损失。修复完故障不等于故障结束，此时还需要进行故障review，防止日后出现相同类似的故障，或者为此故障做降级措施。
   2. 故障原因的定位。故障定位大致可以通过以下来确认：新发布和配置改动，业务和机器监控报警，是否有慢sql，是否有异常日志。
3. 跟串联流程模块mock数据并串联跑通，在一起测试的过程中出现了一些bug，但还是及时的修复了，目前可以正常跑通并得到预期的结果。明日将进行并发测试，检查并发问题。
4. 学习HttpClient的用法，并整理出wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=607015979



## 明日计划

1. 进行并发测试，检查并发问题。
2. 学习HttpClient使用自定义连接池。
3. 完善QConfig学习笔记



# 9.8

1. 解决并发测试时数据缺失问题。原因是较短时间内对业务接口发起较多请求的话，业务接口会进行风控，返回无效数据，导致diff解析失败。此原因跟需求方确认后暂不处理。

2. 学习线上操作技巧和注意事项面授课。

   1. 基于portal的线上常见操作：

      环境管理：当prepare的profile与prod一致，部署影响了线上时，须直接操作prepare机器下线，因为prepare无rtag，无法做回滚操作。
      扩容/重启/上下线：扩容之后观察线上日志有无异常日志，如数据库权限异常等；观察核心监控是否有指标异常、丢失；观察单机监控确认新机器Nginx生效并正常接收请求。

   2. 线上问题排查：

      Bistoury：排查死锁/BLOCK——jstack、内存/GC分析——heapdump。要注意的是内存dump会触发长时间STW，造成服务请求假死。在执行dump之前，一定要对机器下线。

3. 学习HttpClient使用自定义连接池、完善QConfig学习笔记。

   1. 连接池释放连接的时候，并不会直接对TCP连接的状态有任何改变，只是维护了两个Set集合（leased和avaliabled），leased代表被占用的连接集合，avaliabled代表可用的连接的集合，释放连接的时候仅仅是将连接从leased中remove掉了，并把连接放到avaliabled集合中。



# 9.9

## 学习与收获

今日主要的任务就是sql语句审核以及code review。

1. 在sql语句审核过程中，第一次使用补天这个平台，在这个平台上进行sql提交与检测。经过这次的sql检测，有以下收获
   1. 每个表的id字段应该设为unsigned int，因为一个表记录的数量一般不超过5KW条，远远达不到int的上限。
   2. 每个表以及表中的每个字段都得加上备注。每个字段都得为not null并且要有默认值。
   3. 对于长度太长的varchar来说是不允许建索引的。例如varchar(255)的字段是不允许建索引的。
2. 在code review过程中，征哥给我们传授了很多开发时需要注意的一些规范以及技巧。
   1. 对于异常情况，一般都需要同时打印error日志和打监控的，对于业务场景当中的一些自定义的业务异常的情况下，也可能不用error级别的日志。
   2. 在程序中，不到万不得已不使用锁，一般可以考虑其他情况来避免加锁，比如使用线程安全的类（ConcurrentHashMap代替HashMap），采用异步方式。



# 9.13

## 学习与收获

今日主要任务是前后端整体联调然后解决联调时遇到的问题，进行线上发布方案的探讨以及在线debug验证qtrace是否真的为null。

1. 在测试中遇到了数据量太大导致varchar(255)存不下，因此将该字段的类型改成了blob，但此时获取出来后出现乱码，后面使用text则正常。
   1. 二者相同点：都不允许有默认值。保存或检索数据不删除尾部空格。索引在blob或者text上必须执行索引前缀的长度。
   2. 二者不同点：text大小写不敏感，而blob排序和比较以大小写敏感的方式执行。text是非二进制字符串，blob存储的是二进制数据。blob可以储存图片, text只能储存纯文本文件。
2. varchar最多能存储65535个字节的数据。因为varchar类型存储变长字段的字符类型，与char类型不同的是，其存储时需要在前缀长度列表加上实际存储的字符，当存储的字符串长度小于255字节时，其需要1字节的空间，当大于255字节时，需要2字节的空间。
3. 从官方文档中我们可以得知当varchar大于某些数值的时候，其会自动转换为text，大概规则如下：
   - 大于varchar（255）变为 tinytext
   - 大于varchar（500）变为 text
   - 大于varchar（20000）变为 mediumtext



问题

- 在数据库中，想将一个原有的字段属性修改为非空，但是显示了以下的错误信息"1138-invalid use of null value"
- 原因：出现该问题的原因可能是数据库该字段原本就已经存在空值，所以会出现这个错误提示



# 9.14

学习与收获

今日主要任务是编写线上发布方案以及测试checklist并修复出现的问题。

1. 与小组成员一同完成上线方案wiki [上线方案wiki](https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=607019661) 
2. 在beta环境完成qconfig配置方面的checklist测试 [checklist测试](https://todolist.qunar.com/flight_case.do?checklistId=359504#home) 
3. 在测试过程中发现当QConfig配置出错（写错配置信息），并不是发生异常而是获取到之前版本的内容。原因是本地缓存了QConfig的内容，而出现错误时没有将缓存清空。
4. 基本在所有的项目中都会存在公司的基本组件，如果获取不到可能是环境不对或者是没有初始化。例如获取qtrace组件时，应该初始化ServletWatcher（不过好像在springcloud中会自动的初始化ServletWatcher，并不需要手动添加）。



问题

在使用idea远程debug的时候，一直出现连接不上的情况，操作步骤跟其他同事一样，可能是因为mac的问题，明日再检查原因。



# 9.15

学习与收获

今天的主要任务是进行前后端的关联发布跟后端进行灰度发布。

1. 解决idea进行远程debug的问题。之前一直连接不上远程的服务，是因为配置中使用的一直是beta环境的本机IP，需要使用远程IP才可以。修复完此问题后沉淀了wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=609630801
2. 了解前后端关联发布。在Portal发布平台中，针对前后端关联，有两种关联方式。
   1. 通过pom文件关联。老项目一般都是使用该方式进行前后端关联发布，耦合度高。
   2. 通过负载均衡转发。解耦合，前后端可以独立发布，只需在对应appcode的负载均衡中指定转发路径即可。但是需要先申请域名。本项目采用的是此种方式进行前后端关联。
3. 由于需求方有部分功能存在bug，所以一直等待其修复。只有其修复完后才可以获取线上数据并跑通整个流程。目前已经灰度发布完成，处于申请es资源的阶段。
4. 在@PostConstruct注解注释的方法中初始化了一个对象，@Qconfig注解注释的方法中使用了这个对象，报了空指针异常。了解到：@PostConstruct注解底层是基于BeanPostProcessor接口实现的，@Qconfig注解是基于beanFactoryPostProcessor实现的，在spring生命周期里beanfactory早于bean的postProcessor。



# 9.16

学习与收获

今天主要的任务是灰度发布然后测试，对中途出现的异常进行修复。

1. 对昨日的前后端关联发布进行总结并整理成wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=609638512
2. 发布到线上之后，通过负载均衡的配置，请求不到后端的数据，调试发现请求路径是linker.corp.qunar.com/linker-api。而后端的基本路径没有linker-api，需要在配置文件中加个项目前缀；
3. 进行全量发布前，需要先发布beta，如果beta发布成功再进行灰度发布，然后再灰度发布中进行功能点的检查，检查无误后才进行全量发布。
4. 每次代码变更push到仓库时，代码覆盖率都会变成0，需要重新测试之后才可以重新计算代码覆盖率。





# 9.19

今天主要是对项目进行验收，编写答辩PPT以及进行预答辩的演习。

1. 项目上线、pm验收较为顺利，与此同时项目导师对上线时的注意事项进行指导，要实时看监控和日志，如果出现问题要立刻回滚，避免影响业务。对所有异常监控的突增或突减都必须了解其原因，不能因为异常数据突然变0了就以为没有异常了，此时可能是服务挂掉了。
2. 学习Springboot采用内置Tomcat启动和外部tomcat启动的区别：
   1. 内置Tomcat启动：直接通过内置Tomcat运行（在内部调用Tomcat的API），不需要额外安装Tomcat。如需修改内置Tomcat的配置，只需要在SpringBoot的配置文件中配置。使用比较方便，快速，直接java -jar命令运行即可。
   2. 外部tomcat启动：传统的应用交付方式，需要安装Tomcat，然后放到wabapps目录下运行war包，可以直接修改Tomcat的配置，相对打成jar包来说没那么快速方便。
   3. 对这两种方式的区别及基本原理整理成了wiki：https://wiki.corp.qunar.com/confluence/pages/viewpage.action?pageId=597005458
