# 什么是分布式事务？

在分布式系统环境下由不同的服务之间通过网络远程协作完成的事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。

分布式事务产生的场景：

1. 多个服务+单个数据库实例：

2. 单个服务+多个数据库实例：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。

3. 多个微服务+多个数据实例：

# 分布式事务基础理论

通过理论知识可以指导我们确定分布式事务控制的目标，从而帮助我们理解每个解决方案。

 

## CAP理论

CAP是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍性。

- Consistency一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态。实现一致性一般需要进行节点之间的同步操作，比较消耗性能。

- Availability可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。一般可用性允许节点直接存在一定数据的不一致，来保证节点的可用性。

- Partition tolerance分区容忍性：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供服务。

分区容忍性是分布式系统具备的基本能力。在所有分布式事务场景中不会同时具备CAP三个特性，因为在具备了P的前提下C和A是不能共存的。

所以CAP有以下组合，可以根据特定场景选择合适的分布式目标：

- CA：放弃分区容错性P，加强一致性和可用性，其实就是传统的单机数据库的选择。

- AP：放弃一致性C，一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

- CP：放弃可用性A，由于分区之间会导致同步时间无限延长(等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据一致了之后再让用户访问系统。

## BASE理论

BASE是**B**asically **A**vailable（基本可用）、**S**oft state（软状态）和**E**ventually consistent（最终一致性）的缩写，基于CAP定理逐步演化而来。

BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到**最终一致性**。

- 基本可用：分布式系统在出现不可预知故障的时候，允许损失部分可用性，从而保证核心功能的可用性。比如时间上的损失，功能上的损失。

- 软状态：允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。

- 最终一致性：最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。

# 分布式事务的解决方案

![](https://pic1.zhimg.com/v2-84c272f5b9370ac87d9c02a6ec0b51d8_r.jpg)

## 2PC(两阶段提交)

2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase）。

两阶段提交协议的角色有：事务管理器（决策者）和资源管理器（参与者）

事务管理器负责向资源管理器发送指令，收集参与者的反馈，做出提交或者回滚决策  
资源管理器接收事务管理器的指令执行事务操作，向事务管理器反馈操作结果，并继续执行事务管理器发送的最终指令。

实现2PC的方案有两个：

- XA方案

- Seata方案

缺点：

1. 性能问题：从事务开始到事务提交或回滚，这期间所有参与者的资源一致处于锁定状态。

2. 数据不一致：极端情况下不管是由于协调者故障，还是网络分区都会有导致数据不一致的风险。

3. 阻塞问题：如果协调者在第一阶段就挂掉了，则所有参与者都会阻塞。

### XA方案

基于数据库的XA规范来实现2PC称为XA方案。XA 规范 描述了全局的事务管理器与局部的资源管理器之间的接口。

为了统一标准，减少行业内不必要的对接成本，国际开放标准组织定义了标准化的分布式事务处理模型**DTP**（Distributed Transaction Processing Reference Model）。

DTP模型定义如下角色：

- AP(Application Program)：即应用程序，可以理解为使用DTP分布式事务的程序。

- RM(Resource Manager)：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。

- TM(Transaction Manager)：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。

执行流程如下：

1. 在准备阶段RM执行实际的业务操作，但不提交事务，资源锁定；

2. 在提交阶段TM会接受RM在准备阶段的执行回复，只要有任一个RM执行失败，TM会通知所有RM执行回滚操作，否则，TM将会通知所有RM提交该事务。提交阶段结束资源锁释放。

XA方案的问题：

1、需要本地数据库支持XA协议。

2、同步等待，资源锁需要等到两个阶段结束才释放，性能较差。

### Seate AT方案

TC、TM、RM：TC作为事务协调器决定提交还是回滚，以及生成全局事务id和分支事务id，然后让TM去通知RM进行提交或回滚。

Seata实现2PC与传统2PC的差别：

架构层次方面，传统2PC方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而Seata的 RM 是以jar包的形式作为中间件层部署在应用程序这一侧的。

两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1 就将本地事务提交，这样就可以省去Phase2持锁的时间，整体提高效率。

seata at 模式默认的隔离级别为读未提交（因为已经提交的sql有可能会回滚）。如果要实现读已提交，select语句需要更改为 SELECT FOR UPDATE 语句。

SELECT FOR UPDATE 语句的执行会向TC申请这些数据的行锁，如果这些数据的锁被其他事务持有，则会等待锁的释放（即读取的相关数据是已提交的）。这个过程中，查询是被 block 住的。在TC中会对写操作以及select for update的sql进行拦截并记录，从而形成全局锁，其他分布式事务使用数据前需要先获取锁，避免当前分布式事务影响其他事务。

缺点：

- 需要创建undolog表进行回滚。

- 由于持有全局锁，在高并发下会有性能问题。

- AT 模式下，默认的数据库隔离级别是: 读取未提交。这一点需要注意，在涉及到强一致性的读，需要加上全局锁，否则会出现脏读。

## TCC补偿事务

TCC（Try-Confirm-Cancel）分布式事务模型相对于 XA 等传统模型，其特征在于它不依赖资源管理器（RM）对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。

首先TCC在事务执行前，通过预留资源的方式把需要的资源事先隔离出来，这样就保证这部分的资源不被其它事务再次使用，然后为操作失败的情况制定了一个补偿操作来进行业务回滚，所以TCC的模式里是允许业务失败的。

TCC分为Try、Confirm、Cancel三个方法， Try阶段主要是进行资源预留，如果Try阶段执行成功，那么本次事务所需要的资源都已经获得，这样在事务提交的时候肯定能提交成功。如果Try阶段失败，那么此时就会调用Cancel操作进行资源释放。

- Try阶段：该阶段主要做业务可行性检查并预留事务所需要的资源，保证预留出来的资源与其它的事务隔离开来。

- Confirm：当所有事务参与者在Try阶段都执行成功后，进入Confirm阶段。此阶段将直接使用Try阶段预留资源进行业务操作。

- cancel: 任意一个参与者在当Try阶段执行失败，则整体进入Cancel阶段，此阶段将释放Try阶段预留的资源。

TCC需要注意三种异常处理分别是**空回滚、幂等、悬挂**:

**幂等**：为了保证TCC二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段 Try、Confirm 和 Cancel 接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。

- 解决思路是每个分支都使用**事务状态表**（包含事务 ID ，分支事务 ID，事务状态），每次执行前都查询事务状态，事务状态为Tried的时候才执行Confirm / Cancel。

**空回滚**：**在没有调用Try 方法的情况下，调用了 Cancel 方法**，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行Try阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的Cancel方法，从而形成空回滚。

- 解决思路是每个分支都使用“**try日志表**”（包含事务 ID 和分支事务 ID），执行 Try 方法里会插入一条记录，表示一阶段执行了。如果执行Cancel 接口则先读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。

**悬挂**：资源悬挂问题发生在**cancel比try先执行**， 如果发送Try请求时发生网络延时，那么请求方会认为业务失败，此时会进入Cancel阶段，当所有的Cancel都执行完之后，整个事务结束。但是之前发生网络延时的请求最终还是发送到了对应的服务，此时会执行Try操作，但是事务已经结束了，没有任何后续流程来提交或者释放Try阶段预留的资源。

- 解决思路是使用“**cancel日志**”表中（包含事务 ID 和分支事务 ID）记录Cancel行为，在执行try之前判断是否执行了cancel，如果有则不执行Try。

优点：

- 性能：不会锁整个资源，只会锁对应业务数据的资源，粒度更小。

- 可靠性：避免2pc协调者单点故障问题。

- 数据一致性：通过业务行为保证数据的最终一致性。

缺点：业务侵入性强，与业务强耦合。

## 可靠消息最终一致性

可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方(消息消费者)一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方则最终事务肯定会达到一致。

在可靠消息最终一致性方案中需要保证消息一定会发送给消费方，所以需要保证发送方消息发送的可靠性，mq消息的可靠性，以及消费者消费的可靠性和幂等性。

- 发送方消息发送的可靠性：本地事务表+轮询保证消息保证消息一定发送出去，轮询时使用mq的手动ack与消息回调。

- mq消息的可靠性：使用消息与队列的持久化保证消息的可靠性。

- 消费者消费的可靠性：使用mq的手动确认机制。

- 消费者消费的幂等性：使用消费表记录消息不会重复被消费。

## 最大努力通知

事务发起方执行完成本地事务后发出一条消息，消息不保证一定可以到达事务参与方，但发起方会提供一个接口给参与方查询消息的内容，如果参与方在规定时间内收不到消息，可以自行查询消息接口。

最大努力通知解决方案有两种：

1. 发起方跟参与方监听同一个消息主题，参与方如果规定时间内没有消费到消息则收到回调发起方接口。适合公司内部使用。

2. 发起方单独使用一个消息通知服务，发起方与消息通知服务监听同一个消息主题，当消息通知服务收到消息之后调用参与方的接口通知其调用发起方接口查询消息内容。适合公司外部使用。

小结：

2PC场景比较适用于内部使用，更强调一致性。

TCC更多的是在业务层进行保证最终一致性。

可靠消息最终一致性跟最大努力通知更强调可用性。可靠消息最终一致性比较适用于内部使用。
